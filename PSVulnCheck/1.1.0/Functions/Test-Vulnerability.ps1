#Helper function for PSVulnCheck

Function Test-Vulnerability {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory)]
        [string[]]  $computerName,
        [string[]]  $KB,
        [string]    $TargetFile,
        [hashtable] $fileVersions,
        [hashtable[]] $Services,
        [string]    $logfile
    )

    if (! $logfile ) {$logfile = "$env:USERPROFILE\$($MyInvocation.MyCommand)-InvokeParallel.log"}

    if ($computerName) {
        $computerName | Invoke-Parallel -LogFile $logFile -RunspaceTimeout 600 -Verbose:$false{
            $computerName      = $_
            $iKB               = $using:KB
            $iFileVersions     = $using:fileversions
            $iTargetFile       = $using:TargetFile
            $iServices         = $using:Services

            $scriptblockGetOsVersion = {
                try   { $ver = (Get-CimInstance win32_operatingsystem).version }
                catch { $ver = (Get-WmiObject win32_operatingsystem).version }

                if     ($ver -match [version] '6.1')        { Write-Output 'Win6_1'}
                elseif ($ver -match [version] '6.2')        { Write-Output 'Win6_2'}
                elseif ($ver -match [version] '6.3')        { Write-Output 'Win6_3'}
                elseif ($ver -match [version] '10.0.10240') { Write-Output 'Win10_10240'}
                elseif ($ver -match [version] '10.0.10586') { Write-Output 'Win10_10586'}
                elseif ($ver -match [version] '10.0.14393') { Write-Output 'Win10_14393'}
                elseif ($ver -match [version] '10.0.15063') { Write-Output 'Win10_15063'}
                else                                        { Write-Output [string]$ver}
            }

            $output = [PSCustomObject]@{ComputerName = $computerName}
			
            #check for proper file version
            if ($iFileVersions -and $iTargetFile) {
                try {
                    $status            = 'Connected'
                    $osVersion         = Invoke-Command -computername $computerName -ErrorAction Stop -scriptblock $scriptblockGetOsVersion
                    $targetFileVersion = [version] $iFileVersions.$OSVersion
                    $pulledFileVersion = Invoke-Command -computername $computerName -ErrorAction Stop -scriptblock { param ([string]$file); (Get-Item -Path $file).VersionInfo } -ArgumentList $iTargetFile
                    $actualFileVersion = [version]("{0}.{1}.{2}.{3}" -f $pulledFileVersion.FileMajorPart, $pulledFileVersion.FileMinorPart, $pulledFileVersion.FileBuildPart, $pulledFileVersion.FilePrivatePart)
                    $fileVersionOK     = $actualFileVersion -ge [version]$targetFileVersion
                    $fileCheckErrors   = $null
                } catch [System.Management.Automation.Remoting.PSRemotingTransportException] {
                    $status            = 'Disconnected'
                    $osVersion         = $null
                    $actualFileVersion = $null
                    $fileVersionOK     = $null
                    $fileCheckErrors   = $_.exception.TransportMessage
                } catch {
                    $status            = 'Unknown'
                    $osVersion         = $null
                    $actualFileVersion = $null
                    $fileVersionOK     = $null
                    $fileCheckErrors   = $_.exception                     
                } finally {
                    $output | Add-Member -MemberType NoteProperty -Name 'OSVersion'         -value $osVersion
                    $output | Add-Member -MemberType NoteProperty -Name 'Status'            -value $status
                    $output | Add-Member -MemberType NoteProperty -Name 'FileVersionOk'     -value $fileVersionOK
                    $output | Add-Member -MemberType NoteProperty -Name 'TargetFile'        -value $iTargetFile
                    $output | Add-Member -MemberType NoteProperty -Name 'TargetFileVersion' -value $targetFileVersion
                    $output | Add-Member -MemberType NoteProperty -Name 'ActualFileVersion' -Value $actualFileVersion
                    $output | Add-Member -MemberType NoteProperty -Name 'FileCheckErrors'   -value $fileCheckErrors
                }
            }

			$patched, $installedKBs, $thisError = $null, $null, $null
            #check for any hotfixes which may be installed
            if ($iKB) {
                try {
                    $hotfixes     = Get-Hotfix -Id $iKB -ComputerName $computerName -ErrorAction Stop
                    $thisError    = $null
                    if ($hotfixes) {
                        $patched      = $true
                        $installedKBs = $hotfixes.HotFixID
                    } else {
                        $patched      = $false
                        $installedKBs = $null
                    }
                } catch [System.ArgumentException] {
                    $thisError    = $_.exception
                    $patched      = $false
					$installedKBs = $false
                } catch {
                    $thisError    = $_.exception
                    $patched      = $false
					$installedKBs = $false
                } finally {
                    $output | Add-Member -MemberType NoteProperty -Name 'Patched'      -Value $patched
                    $output | Add-Member -MemberType NoteProperty -Name 'InstalledKBs' -Value $installedKBs
                    $output | Add-Member -MemberType NoteProperty -Name 'KBErrors'     -Value $kbErrors
                }
            }

            #check for services
            if ($iServices) {
                $Private:ServiceErrors = @()
                $Private:AllServicesOK = $true

                $iServices | ForEach-Object {
                    $presence,$serviceState,$serviceConnStatus = $null,$null, $null
                    $InTargetPresence,$InTargetState,$InTargetStartMode = $true, $true, $true
                    $serviceDefinition = $_
                    
                    Write-Verbose ("Looking for the following services:$($serviceDefinitions | Format-Table | Out-String)")

                    try {
                        $serviceConnStatus = 'Connected'
                        $serviceState = (Get-WmiObject -ComputerName $computerName -Class 'Win32_Service' -filter "Name='$($serviceDefinition.name)'" -ErrorAction Stop)
                        
                        if ($serviceState -eq $null) { $presence = 'Absent' } 
                        else { $presence = 'Present' }
                    }
                    catch {
                        if ($_.exception.message -match 'The RPC server is unavailable.') { #System.Runtime.InteropServices.COMException
                            $serviceConnStatus = 'Disconnected'
                            $presence = 'RPC Unavailable'
                            $Private:ServiceErrors += 'RPC server unavailable'
                        }
                        elseif ($_.exception.message -match 'Access is denied.') { #System.Runtime.InteropServices.COMException
                            $serviceConnStatus = 'AccessDenied'
                            $presence = 'Access Denied'
                            $Private:ServiceErrors += $_.Exception.message
                        } else {
                            $serviceConnStatus = 'Unknown'
                            $Private:ServiceErrors += $_.Exception.message
                        }
                    }
                    finally {
                        #add Target State
                        if ($serviceDefinition.TargetState -ne $null) {
                            $InTargetState = $serviceDefinition.TargetState -eq $serviceState.State
                            $output | Add-Member -MemberType NoteProperty -Name "$($serviceDefinition.name)_TargetState" -Value $serviceDefinition.TargetState
                            $output | Add-Member -MemberType NoteProperty -Name "$($serviceDefinition.name)_State" -Value $serviceState.State
                        }
                        
                        #add Target Start State
                        if ($serviceDefinition.TargetStartMode -ne $null) {
                            $InTargetStartMode = $serviceDefinition.TargetStartMode -eq $serviceState.StartMode
                            $output | Add-Member -MemberType NoteProperty -Name "$($serviceDefinition.name)_TargetStartMode" -Value $serviceDefinition.TargetStartMode
                            $output | Add-Member -MemberType NoteProperty -Name "$($serviceDefinition.name)_StartMode" -Value $serviceState.StartMode
                        }

                        #add Target Presence
                        if ($serviceDefinition.TargetPresence -ne $null) {
                            $InTargetPresence = ($serviceDefinition.TargetPresence -eq $presence)
                            $output | Add-Member -MemberType NoteProperty -Name "$($serviceDefinition.name)_TargetPresence" -Value $serviceDefinition.TargetPresence
                            $output | Add-Member -MemberType NoteProperty -Name "$($serviceDefinition.name)_Presence" -Value $presence
                        }

                        #update AllServicesOK with this Service's information
                        if ($serviceDefinition.TargetPresence -eq 'Absent' -and $InTargetPresence) {
                            $thisServiceOK = $true
                            $Private:AllServicesOK = $Private:AllServicesOK -and $thisServiceOK
                        } elseif ([bool]($serviceConnStatus -eq 'Disconnected' -or $serviceConnStatus -eq 'AccessDenied')) {
                            $Private:AllServicesOK = $null
                        } else {
                            #default - check all three
                            $thisServiceOK = $InTargetPresence -and $InTargetState -and $InTargetStartMode
                            $Private:AllServicesOK = $Private:AllServicesOK -and $thisServiceOK
                        }

                        #add status property if it doesn't already exist
                        if ($output.psobject.properties.name -contains 'Status') {
                            #if the previous state was connected, update it with this state as it might reveal an error
                            #otherwise, don't overwrite previous error states
                            if ($output.status -eq 'Connected') {$output.status = $serviceConnStatus}
                        } else {
                            $output | Add-Member -MemberType NoteProperty -Name 'Status' -Value $serviceConnStatus
                        }
                    }
                }
                
                #Add boolean checking for any service vulnerable
                $output | Add-Member -MemberType NoteProperty -Name AllServicesOK -Value $Private:AllServicesOK 
                
                #Add any errors if they were presents
                if ($Private:ServiceErrors.count -gt 0) { 
                    $output | Add-Member -MemberType NoteProperty -Name ServiceErrors -Value $Private:ServiceErrors 
                }
            }

            Write-Output $output
        }

        remove-item -Path $logfile
    } else {
        Write-Warning "Parameter -computerName could name be validated.  Value was:$computername"
    }
}
