#Helper function for PSVulnCheck

Function Test-Vulnerability {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory)]
        [string[]]  $computerName,
        [string[]]  $KB,
        [string]    $TargetFile,
        [hashtable] $fileVersions,
        [string]    $logfile
    )

    if (! $logfile ) {$logfile = "$env:USERPROFILE\$($MyInvocation.MyCommand)-InvokeParallel.log"}

    if ($computerName) {
        $computerName | Invoke-Parallel -LogFile $logFile -RunspaceTimeout 600 {
            $computerName      = $_
            $iKB               = $using:KB
            $iFileVersions     = $using:fileversions
            $iTargetFile       = $using:TargetFile

            $scriptblockGetOsVersion = {
                try   { $ver = (Get-CimInstance win32_operatingsystem).version }
                catch { $ver = (Get-WmiObject win32_operatingsystem).version }

                if     ($ver -match [version] '6.1')        { Write-Output 'Win6_1'}
                elseif ($ver -match [version] '6.2')        { Write-Output 'Win6_2'}
                elseif ($ver -match [version] '6.3')        { Write-Output 'Win6_3'}
                elseif ($ver -match [version] '10.0.10240') { Write-Output 'Win10_10240'}
                elseif ($ver -match [version] '10.0.10586') { Write-Output 'Win10_10586'}
                elseif ($ver -match [version] '10.0.14393') { Write-Output 'Win10_14393'}
                elseif ($ver -match [version] '10.0.15063') { Write-Output 'Win10_15063'}
                else                                        { Write-Output [string]$ver}
            }

            $output = [PSCustomObject]@{ComputerName = $computerName}
			
            #check for proper file version
            if ($iFileVersions -and $iTargetFile) {
                try {
                    $status            = 'Connected'
                    $osVersion         = Invoke-Command -computername $computerName -ErrorAction Stop -scriptblock $scriptblockGetOsVersion
                    $targetFileVersion = [version] $iFileVersions.$OSVersion
                    $pulledFileVersion = Invoke-Command -computername $computerName -ErrorAction Stop -scriptblock { param ([string]$file); (Get-Item -Path $file).VersionInfo } -ArgumentList $iTargetFile
                    $actualFileVersion = [version]("{0}.{1}.{2}.{3}" -f $pulledFileVersion.FileMajorPart, $pulledFileVersion.FileMinorPart, $pulledFileVersion.FileBuildPart, $pulledFileVersion.FilePrivatePart)
                    $fileVersionOK     = $actualFileVersion -ge [version]$targetFileVersion
                    $fileCheckErrors   = $null
                } catch [System.Management.Automation.Remoting.PSRemotingTransportException] {
                    $status            = 'Disconnected'
                    $osVersion         = $null
                    $actualFileVersion = $null
                    $fileVersionOK     = $null
                    $fileCheckErrors   = $_.exception.TransportMessage
                } catch {
                    $status            = 'Unknown'
                    $osVersion         = $null
                    $actualFileVersion = $null
                    $fileVersionOK     = $null
                    $fileCheckErrors   = $_.exception                     
                } finally {
                    $output | Add-Member -MemberType NoteProperty -Name 'OSVersion'         -value $osVersion
                    $output | Add-Member -MemberType NoteProperty -Name 'Status'            -value $status
                    $output | Add-Member -MemberType NoteProperty -Name 'FileVersionOk'     -value $fileVersionOK
                    $output | Add-Member -MemberType NoteProperty -Name 'TargetFile'        -value $iTargetFile
                    $output | Add-Member -MemberType NoteProperty -Name 'TargetFileVersion' -value $targetFileVersion
                    $output | Add-Member -MemberType NoteProperty -Name 'ActualFileVersion' -Value $actualFileVersion
                    $output | Add-Member -MemberType NoteProperty -Name 'FileCheckErrors'   -value $fileCheckErrors
                }
            }

			$patched, $installedKBs, $thisError = $null, $null, $null
            #check for any hotfixes which may be installed
            if ($iKB) {
                try {
                    $hotfixes     = Get-Hotfix -Id $iKB -ComputerName $computerName -ErrorAction Stop
                    $thisError    = $null
                    if ($hotfixes) {
                        $patched      = $true
                        $installedKBs = $hotfixes.HotFixID
                    } else {
                        $patched      = $false
                        $installedKBs = $null
                    }
                } catch [System.ArgumentException] {
                    $thisError    = $_.exception
                    $patched      = $false
					$installedKBs = $false
                } catch {
                    $thisError    = $_.exception
                    $patched      = $false
					$installedKBs = $false
                } finally {
                    $output | Add-Member -MemberType NoteProperty -Name 'Patched'      -Value $patched
                    $output | Add-Member -MemberType NoteProperty -Name 'InstalledKBs' -Value $installedKBs
                    $output | Add-Member -MemberType NoteProperty -Name 'KBErrors'     -Value $kbErrors
                }
            }

            Write-Output $output
        }

        remove-item -Path $logfile
    } else {
        Write-Warning "Parameter -computerName could name be validated.  Value was:$computername"
    }
}
